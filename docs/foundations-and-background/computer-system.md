
## CPU操作
每个cpu都有一个程序计数器(PC), 一个指令指针(IP)，一个标志或状态寄存器(SR)，一个栈指针(SP)，以及少数通用寄存器


- PC 指定下一个在内存中的待执行指令
- SR包含了当前CPU的状态信息
- SP指向当前栈顶，栈是一段内存中特定的内存区域，可以对其进行进栈、出栈和返回


## 系统模式和用户模式
cpu有两种执行模式，如果SR.mode=0，则执行系统模式，如果SR.mode=1则执行用户模式

- 在系统模式下，cpu能执行任何指令以及访问任何内存，
- 在用户模式下，cpu不能执行特权指令，如I/O操作指令，或修改SR.mode的指令，内存访问区域只在应用层


当然，也有许多系统采用多个比特位指定更多的特权层，
本系统只采用两个模式

要想让cpu从用户模式切换到系统模式的唯一方法如下：

- 异常或traps
- 中断
- 系统调用

## 内存和内存模型

通常cpu有一个一级缓存(L1)，当然，也可能有L2和L3级缓存

## 虚拟地址和物理地址

通常，cpu在程序的逻辑或虚拟地址(VA)空间中执行，这不同于内存中的实际或物理地址(PA)，
在执行期间，cpu内存管理硬件自动翻译或解析虚拟地址到物理地址。


### 在x86 16位真机模式中
cpu将内存看成四个段，一个内存段是一个64KB的内存块，一一个内存段地址的低4位总是0,
高16位代表真实的20位段地址

cpu有4个16位段寄存器，分别是：CS,CS,SS,ES

一个程序则由四个唯一部分组成：代码、数据、栈、和其它节，每个刚好是64KB的大小

在一个程序中，每个地址是一个16位虚拟地址VA，代表相对于程序的节的偏移，因此，也是段内偏移

对于每一个虚拟地址VA,cpu使用相应的段寄存器去映射出一个物理地址PA，公式如下：
```
(20-bit)PA = (段寄存器<<4) + (16-bit)VA
```

- 当取指令时，cpu使用默认的CS寄存器，
- 当访问栈时，使用默认的SS寄存器
- 当读取和写入数据时，使用默认的DS寄存器
- 如果指令是一个ES字节的前缀，则使用ES寄存器

## I/O设备和I/Oc操作
I/O设备是典型的块和字符设备

块设备有硬盘、CDROM，通过分片或分块传输数据

字符设备有终端和控制台，通过字符传输数据

usb驱动，物理上传输数据是串行，但是却作为块设备


首先，cpu检查设备状态，如果设备已准备，cpu会发出一个I/O命令启动设备，
然后重复检查设备状态直至结束

DMA控制器负责在内存和I/O设备之间传输数据，当DMA传输数据完成，会通过中断通知cpu，
cpu响应中断，检查I/O完成情况以及确定下一步做什么。

I/O处理器可以通过复杂的I/O程序在不需要cpu监管下执行I/O操作



## 操作系统
一个操作系统提供如下功能：

- 进程管理
- 内存管理
- 文件系统支持
- 设备驱动
- 网络

## a.out文件的内容
a.out文件包含以下节：

- header：头部包含加载信息和文件大小
    - tsize code节大小
    - dsize data节大小（全局初始化和本地静态数据）
    - bsize bss节大小（全局未初始化和本地静态数据）
    - total_size a.out文件加载时的大小

- code节
- data节
- 符号表

## 程序执行
在命令行模式下运行程序，sh会先fork一个子进程并等待子进程结束，当子进程运行时，其步骤如下：

#### 读取a.out头部信息，确定需要的总内存大小
totalSize = _brk + stackSize

#### 分配一个内存大小为totalSize的内存区域以便执行程序
申请内存成功后，加载code和data节到内存区域，在内存地址末端，清空bss节为0，
所有未初始化全局变量以及本地静态变量使用0初始化，执行期间，栈往低地址方向增长


#### 开始执行新镜像
丢弃旧镜像，执行新镜像

#### 执行main函数
从crt0.o开始执行，其会调用main函数，并将参数传递给main函数

## 每个cpu有以下寄存器或装备

- PC(IP)：指向下一条执行指令
- SP(SP)：指向栈顶
- FP(BP)：指向当前执行函数的栈帧
- 返回值寄存器（AX）：返回函数值


